/* pngquant.c - quantize the colors in an alphamap down to a specified number
**
** Copyright (C) 1989, 1991 by Jef Poskanzer.
** Copyright (C) 1997, 2000, 2002 by Greg Roelofs; based on an idea by
**                                Stefan Schneider.
** Â© 2009-2013 by Kornel Lesinski.
**
** Permission to use, copy, modify, and distribute this software and its
** documentation for any purpose and without fee is hereby granted, provided
** that the above copyright notice appear in all copies and that both that
** copyright notice and this permission notice appear in supporting
** documentation.  This software is provided "as is" without express or
** implied warranty.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <limits.h>

#if !defined(__STDC_VERSION__) || __STDC_VERSION__ < 199900L
#error "This program requires C99, e.g. -std=c99 switch in GCC. MSVC doesn't support C newer than '89, please use MinGW on Windows."
#error "Ignore torrent of syntax errors that may follow. It's only because compiler is set to use too old C version."
#endif

#ifdef _OPENMP
#include <omp.h>
#else
#define omp_get_max_threads() 1
#define omp_get_thread_num() 0
#endif

#include "libimagequant.h"

#include "pam.h"
#include "mediancut.h"
#include "nearest.h"
#include "blur.h"
#include "viter.h"

#define LIQ_HIGH_MEMORY_LIMIT (1<<26)  /* avoid allocating buffers larger than 64MB */

// each structure has a pointer as a unique identifier that allows type checking at run time
static const char *const liq_attr_magic = "liq_attr", *const liq_image_magic = "liq_image",
     *const liq_result_magic = "liq_result", *const liq_remapping_result_magic = "liq_remapping_result",
     *const liq_freed_magic = "free";
#define CHECK_STRUCT_TYPE(attr, kind) liq_crash_if_invalid_handle_pointer_given((liq_attr*)attr, kind ## _magic)
#define CHECK_USER_POINTER(ptr) liq_crash_if_invalid_pointer_given(ptr)

struct liq_attr {
    const char *magic_header;
    void* (*malloc)(size_t);
    void (*free)(void*);

    double target_mse, max_mse, voronoi_iteration_limit;
    float min_opaque_val;
    unsigned int max_colors, max_histogram_entries;
    unsigned int min_posterization_output /* user setting */, min_posterization_input /* speed setting */;
    unsigned int voronoi_iterations, feedback_loop_trials;
    bool last_index_transparent, use_contrast_maps, use_dither_map, fast_palette;
    unsigned int speed;
    liq_log_callback_function *log_callback;
    void *log_callback_user_info;
    liq_log_flush_callback_function *log_flush_callback;
    void *log_flush_callback_user_info;
};

struct liq_image {
    const char *magic_header;
    void* (*malloc)(size_t);
    void (*free)(void*);

    f_pixel *f_pixels;
    rgba_pixel **rows;
    double gamma;
    unsigned int width, height;
    unsigned char *noise, *edges, *dither_map;
    rgba_pixel *pixels, *temp_row;
    f_pixel *temp_f_row;
    liq_image_get_rgba_row_callback *row_callback;
    void *row_callback_user_info;
    float min_opaque_val;
    bool free_pixels, free_rows, free_rows_internal;
};

typedef struct liq_remapping_result {
    const char *magic_header;
    void* (*malloc)(size_t);
    void (*free)(void*);

    unsigned char *pixels;
    colormap *palette;
    liq_palette int_palette;
    double gamma, palette_error;
    float dither_level;
    bool use_dither_map;
} liq_remapping_result;

struct liq_result {
    const char *magic_header;
    void* (*malloc)(size_t);
    void (*free)(void*);

    liq_remapping_result *remapping;
    colormap *palette;
    liq_palette int_palette;
    double gamma, palette_error;
    float dither_level;
    int min_posterization_output;
    bool use_dither_map, fast_palette;
};

static liq_result *pngquant_quantize(histogram *hist, const liq_attr *options, double gamma);
static void modify_alpha(liq_image *input_image, rgba_pixel *const row_pixels);
static void contrast_maps(liq_image *image);
static histogram *get_histogram(liq_image *input_image, liq_attr *options);
static const rgba_pixel *liq_image_get_row_rgba(liq_image *input_image, unsigned int row);
static const f_pixel *liq_image_get_row_f(liq_image *input_image, unsigned int row);
static void liq_remapping_result_destroy(liq_remapping_result *result);

static void liq_verbose_printf(const liq_attr *context, const char *fmt, ...)
{
    if (context->log_callback) {
        va_list va;
        va_start(va, fmt);
        int required_space = vsnprintf(NULL, 0, fmt, va)+1; // +\0
        va_end(va);

        char buf[required_space];
        va_start(va, fmt);
        vsnprintf(buf, required_space, fmt, va);
        va_end(va);

        context->log_callback(context, buf, context->log_callback_user_info);
    }
}

inline static void verbose_print(const liq_attr *attr, const char *msg)
{
    if (attr->log_callback) attr->log_callback(attr, msg, attr->log_callback_user_info);
}

static void liq_verbose_printf_flush(liq_attr *attr)
{
    if (attr->log_flush_callback) attr->log_flush_callback(attr, attr->log_flush_callback_user_info);
}

#if USE_SSE
inline static bool is_sse2_available()
{
#if (defined(__x86_64__) || defined(__amd64))
    return true;
#else
    int a,b,c,d;
        cpuid(1, a, b, c, d);
    return d & (1<<26); // edx bit 26 is set when SSE2 is present
#endif
}
#endif

/* make it clear in backtrace when user-supplied handle points to invalid memory */
LIQ_EXPORT bool liq_crash_if_invalid_handle_pointer_given(const liq_attr *user_supplied_pointer, const char *const expected_magic_header) NEVER_INLINE;
LIQ_EXPORT bool liq_crash_if_invalid_handle_pointer_given(const liq_attr *user_supplied_pointer, const char *const expected_magic_header)
{
    if (!user_supplied_pointer) return false;

    if (user_supplied_pointer->magic_header == liq_freed_magic) {
        fprintf(stderr, "%s used after being freed", expected_magic_header);
        // this is not normal error handling, this is programmer error that should crash the program.
        // program cannot safely continue if memory has been used after it's been freed.
        // abort() is nasty, but security vulnerability may be worse.
        abort();
    }

    return user_supplied_pointer->magic_header == expected_magic_header;
}

LIQ_EXPORT bool liq_crash_if_invalid_pointer_given(void *pointer) NEVER_INLINE;
LIQ_EXPORT bool liq_crash_if_invalid_pointer_given(void *pointer)
{
    if (!pointer) return false;
    // Force a read from the given (potentially invalid) memory location in order to check early whether this crashes the program or not.
    // It doesn't matter what value is read, the code here is just to shut the compiler up about unused read.
    char test_access = *((volatile char *)pointer);
    return test_access || true;
}

static double quality_to_mse(long quality)
{
    if (quality == 0) return MAX_DIFF;
    if (quality == 100) return 0;

    // curve fudged to be roughly similar to quality of libjpeg
    // except lowest 10 for really low number of colors
    const double extra_low_quality_fudge = MAX(0,0.016/(0.001+quality) - 0.001);
    return extra_low_quality_fudge + 2.5/pow(210.0 + quality, 1.2) * (100.1-quality)/100.0;
}

static unsigned int mse_to_quality(double mse)
{
    for(int i=100; i > 0; i--) {
        if (mse <= quality_to_mse(i)) return i;
    }
    return 0;
}

LIQ_EXPORT liq_error liq_set_quality(liq_attr* attr, int minimum, int target)
{
    if (!CHECK_STRUCT_TYPE(attr, liq_attr)) return LIQ_INVALID_POINTER;
    if (target < 0 || target > 100 || target < minimum || minimum < 0) return LIQ_VALUE_OUT_OF_RANGE;

    attr->target_mse = quality_to_mse(target);
    attr->max_mse = quality_to_mse(minimum);
    return LIQ_OK;
}

LIQ_EXPORT liq_error liq_get_quality(liq_attr *attr, int *minimum, int *target)
{
    if (!CHECK_STRUCT_TYPE(attr, liq_attr)) return LIQ_INVALID_POINTER;
    if (!CHECK_USER_POINTER(minimum)) return LIQ_INVALID_POINTER;
    if (!CHECK_USER_POINTER(target)) return LIQ_INVALID_POINTER;

    *minimum = mse_to_quality(attr->max_mse);
    *target = mse_to_quality(attr->target_mse);
    return LIQ_OK;
}

LIQ_EXPORT liq_error liq_set_max_colors(liq_attr* attr, int colors)
{
    if (!CHECK_STRUCT_TYPE(attr, liq_attr)) return LIQ_INVALID_POINTER;
    if (colors < 2 || colors > 256) return LIQ_VALUE_OUT_OF_RANGE;

    attr->max_colors = colors;
    return LIQ_OK;
}

LIQ_EXPORT int liq_get_max_colors(liq_attr *attr)
{
    if (!CHECK_STRUCT_TYPE(attr, liq_attr)) return -1;

    return attr->max_colors;
}

LIQ_EXPORT liq_error liq_set_min_posterization(liq_attr *attr, int bits)
{
    if (!CHECK_STRUCT_TYPE(attr, liq_attr)) return LIQ_INVALID_POINTER;
    if (bits < 0 || bits > 4) return LIQ_VALUE_OUT_OF_RANGE;

    attr->min_posterization_output = bits;
    return LIQ_OK;
}

LIQ_EXPORT int liq_get_min_posterization(liq_attr *attr)
{
    if (!CHECK_STRUCT_TYPE(attr, liq_attr)) return -1;

    return attr->min_posterization_output;
}

LIQ_EXPORT liq_error liq_set_speed(liq_attr* attr, int speed)
{
    if (!CHECK_STRUCT_TYPE(attr, liq_attr)) return LIQ_INVALID_POINTER;
    if (speed < 1 || speed > 10) return LIQ_VALUE_OUT_OF_RANGE;

    int iterations = MAX(8-speed,0); iterations += iterations * iterations/2;
    attr->voronoi_iterations = iterations;
    attr->voronoi_iteration_limit = 1.0/(double)(1<<(23-speed));
    attr->feedback_loop_trials = MAX(56-9*speed, 0);

    attr->max_histogram_entries = (1<<17) + (1<<18)*(10-speed);
    attr->min_posterization_input = (speed >= 8) ? 1 : 0;
    attr->fast_palette = (speed >= 7);
    attr->use_dither_map = (speed <= (omp_get_max_threads() > 1 ? 7 : 5)); // parallelized dither map might speed up floyd remapping
    attr->use_contrast_maps = (speed <= 7) || attr->use_dither_map;
    attr->speed = speed;
    return LIQ_OK;
}

LIQ_EXPORT int liq_get_speed(liq_attr *attr)
{
    if (!CHECK_STRUCT_TYPE(attr, liq_attr)) return -1;

    return attr->speed;
}

LIQ_EXPORT liq_error liq_set_output_gamma(liq_result* res, double gamma)
{
    if (!CHECK_STRUCT_TYPE(res, liq_result)) return LIQ_INVALID_POINTER;
    if (gamma <= 0 || gamma >= 1.0) return LIQ_VALUE_OUT_OF_RANGE;

    if (res->remapping) {
        liq_remapping_result_destroy(res->remapping);
        res->remapping = NULL;
    }

    res->gamma = gamma;
    return LIQ_OK;
}

LIQ_EXPORT liq_error liq_set_min_opacity(liq_attr* attr, int min)
{
    if (!CHECK_STRUCT_TYPE(attr, liq_attr)) return LIQ_INVALID_POINTER;
    if (min < 0 || min > 255) return LIQ_VALUE_OUT_OF_RANGE;

    attr->min_opaque_val = (double)min/255.0;
    return LIQ_OK;
}

LIQ_EXPORT int liq_get_min_opacity(liq_attr *attr)
{
    if (!CHECK_STRUCT_TYPE(attr, liq_attr)) return -1;

    return MIN(255, 256.0 * attr->min_opaque_val);
}

LIQ_EXPORT void liq_set_last_index_transparent(liq_attr* attr, int is_last)
{
    if (!CHECK_STRUCT_TYPE(attr, liq_attr)) return;

    attr->last_index_transparent = !!is_last;
}

LIQ_EXPORT void liq_set_log_callback(liq_attr *attr, liq_log_callback_function *callback, void* user_info)
{
    if (!CHECK_STRUCT_TYPE(attr, liq_attr)) return;

    liq_verbose_printf_flush(attr);
    attr->log_callback = callback;
    attr->log_callback_user_info = user_info;
}

LIQ_EXPORT void liq_set_log_flush_callback(liq_attr *attr, liq_log_flush_callback_function *callback, void* user_info)
{
    if (!CHECK_STRUCT_TYPE(attr, liq_attr)) return;

    attr->log_flush_callback = callback;
    attr->log_flush_callback_user_info = user_info;
}

LIQ_EXPORT liq_attr* liq_attr_create()
{
    return liq_attr_create_with_allocator(NULL, NULL);
}

LIQ_EXPORT void liq_attr_destroy(liq_attr *attr)
{
    if (!CHECK_STRUCT_TYPE(attr, liq_attr)) return;

    liq_verbose_printf_flush(attr);

    attr->magic_header = liq_freed_magic;
    attr->free(attr);
}

LIQ_EXPORT liq_attr* liq_attr_copy(liq_attr *orig)
{
    if (!CHECK_STRUCT_TYPE(orig, liq_attr)) return NULL;

    liq_attr *attr = orig->malloc(sizeof(liq_attr));
    if (!attr) return NULL;
    *attr = *orig;
    return attr;
}

static void *liq_aligned_malloc(size_t size)
{
    unsigned char *ptr = malloc(size + 16);
    if (!ptr) return NULL;

    uintptr_t offset = 16 - ((uintptr_t)ptr & 15); // also reserves 1 byte for ptr[-1]
    ptr += offset;
    assert(0 == (((uintptr_t)ptr) & 15));
    ptr[-1] = offset ^ 0x59; // store how much pointer was shifted to get the original for free()
    return ptr;
}

static void liq_aligned_free(void *ptr)
{
    uintptr_t offset = ((unsigned char *)ptr)[-1] ^ 0x59;
    ptr -= offset;
    assert(offset > 0 && offset <= 16);
    free(ptr);
}

LIQ_EXPORT liq_attr* liq_attr_create_with_allocator(void* (*custom_malloc)(size_t), void (*custom_free)(void*))
{
#if USE_SSE
    if (!is_sse2_available()) {
        return NULL;
    }
#endif
    if (!custom_malloc && !custom_free) {
        custom_malloc = liq_aligned_malloc;
        custom_free = liq_aligned_free;
    } else if (!custom_malloc != !custom_free) {
        return NULL; // either specify both or none
    }

    liq_attr *attr = custom_malloc(sizeof(liq_attr));
    if (!attr) return NULL;
    *attr = (liq_attr) {
        .magic_header = liq_attr_magic,
        .malloc = custom_malloc,
        .free = custom_free,
        .max_colors = 256,
        .min_opaque_val = 1, // whether